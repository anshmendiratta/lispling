/// `left_child`: `TOKEN`
/// `right_child`: equals `next_node` that is a recursive
#[derive(Debug, Clone)]
pub struct ASTNode {
    pub left_child: TOKEN,
    pub next_node: Option<Box<ASTNode>>,
}

/// Struct representing a token generated by the lexer
#[derive(Debug, Clone, PartialEq)]
pub struct TOKEN {
    pub kind: TOKENTYPE,
    pub value: Option<REPDATA>,
}

/// Sub-struct of `TOKEN` that does not store values
#[derive(Debug, Clone, PartialEq)]
pub enum TOKENTYPE {
    PRINT,
    STRING,
    FUNCTION,
    RPAREN,
    LPAREN,
    RETURN,
    NULL,
}

/// Sub-struct of `TOKEN` that stores values depending on the `TOKENTYPE`
#[derive(Debug, Clone, PartialEq)]
pub enum REPDATA {
    STRIN
    UINT(usize),
    IINT(isize),
}

impl TOKEN {
    pub fn as_string(&self) -> String {
        match self.kind {
            TOKENTYPE::PRINT => "PRINT".to_owned(),
            TOKENTYPE::STRING => format!("{:?}", self.value),
            TOKENTYPE::FUNCTION => "FUNCTION".to_owned(),
            TOKENTYPE::RPAREN => "RPAREN".to_owned(),
            TOKENTYPE::LPAREN => "LPAREN".to_owned(),
            TOKENTYPE::RETURN => format!("{:?}", self.value),
            TOKENTYPE::NULL => "NULL".to_owned(),
        }
    }
}

impl From<TOKENTYPE> for TOKEN {
    fn from(value: TOKENTYPE) -> Self {
        let self_default_value = match &value {
            TOKENTYPE::PRINT => Some(REPDATA::STRING("".to_string())),
            TOKENTYPE::STRING => Some(REPDATA::STRING("".to_string())),
            _ => None,
        };

        TOKEN {
            kind: value,
            value: self_default_value,
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::primitives::REPDATA;

    use super::{TOKEN, TOKENTYPE};

    #[test]
    fn check_token_into() {
        let tokentype_1 = TOKENTYPE::LPAREN;
        let tokentype_2 = TOKENTYPE::STRING;
        let expected_token_1 = TOKEN {
            kind: TOKENTYPE::LPAREN,
            value: None,
        };
        let expected_token_2 = TOKEN {
            kind: TOKENTYPE::STRING,
            value: Some(REPDATA::STRING("".to_string())),
        };

        assert_eq!(expected_token_1, tokentype_1.into());
        assert_eq!(expected_token_2, tokentype_2.into());
    }
}
