#[derive(Debug, PartialEq)]
pub enum Error {
    ConsistentScope(String),
}

/// `left_child`: `TOKEN`
/// `right_child`: equals `next_node` that is a recursive
#[derive(Debug, Clone, PartialEq)]
pub struct ASTNode {
    pub left_child: Token,
    pub next_node: Option<Box<ASTNode>>,
}

/// Struct representing a token generated by the lexer
#[derive(Debug, Clone, PartialEq)]
pub struct Token {
    pub kind: TokenType,
    pub value: Option<RepData>,
}

/// Sub-struct of `TOKEN` that does not store values
#[derive(Debug, Clone, PartialEq)]
pub enum TokenType {
    PRINT,
    STRING,
    FUNCTION,
    RPAREN,
    LPAREN,
    RETURN,
    NULL,
    NUMBER,
    BINOP(InfixOperation),
}

#[derive(Debug, Clone, PartialEq)]
pub enum InfixOperation {
    Addition,
    Subtraction,
    Multiplication,
    Division,
}

/// Sub-struct of `TOKEN` that stores values depending on the `TOKENTYPE`
#[derive(Debug, Clone, PartialEq)]
pub enum RepData {
    STRING(String),
    NUMBER(Number),
}

#[derive(Debug, Clone, PartialEq)]
pub enum Number {
    UINT(usize),
    IINT(isize),
}

impl Token {
    pub fn as_string(&self) -> String {
        match &self.kind {
            TokenType::PRINT => "PRINT".to_owned(),
            TokenType::STRING => format!("{:?}", self.value),
            TokenType::FUNCTION => "FUNCTION".to_owned(),
            TokenType::RPAREN => "RPAREN".to_owned(),
            TokenType::LPAREN => "LPAREN".to_owned(),
            TokenType::RETURN => format!("{:?}", self.value),
            TokenType::NULL => "NULL".to_owned(),
            TokenType::BINOP(op) => format!("{:?}", op),
            TokenType::NUMBER => format!("NUMBER({:?})", self.value),
        }
    }
}

impl From<TokenType> for Token {
    fn from(value: TokenType) -> Self {
        let self_default_value = match &value {
            TokenType::PRINT => Some(RepData::STRING("".to_string())),
            TokenType::STRING => Some(RepData::STRING("".to_string())),
            _ => None,
        };

        Token {
            kind: value,
            value: self_default_value,
        }
    }
}

impl ASTNode {
    pub fn get_next_node(&self) -> Option<Self> {
        if let Some(next_node) = self.next_node.clone() {
            return Some(*next_node);
        }

        None
    }
}

#[cfg(test)]
mod tests {
    use crate::primitives::RepData;

    use super::{ASTNode, Token, TokenType};

    #[test]
    fn check_token_into() {
        let tokentype_1 = TokenType::LPAREN;
        let tokentype_2 = TokenType::STRING;
        let expected_token_1 = Token {
            kind: TokenType::LPAREN,
            value: None,
        };
        let expected_token_2 = Token {
            kind: TokenType::STRING,
            value: Some(RepData::STRING("".to_string())),
        };

        assert_eq!(expected_token_1, tokentype_1.into());
        assert_eq!(expected_token_2, tokentype_2.into());
    }

    #[test]
    pub fn extract_next_node() {
        let child_node: ASTNode = ASTNode {
            left_child: TokenType::NULL.into(),
            next_node: None,
        };
        let root_node: ASTNode = ASTNode {
            left_child: TokenType::NULL.into(),
            next_node: Some(Box::new(child_node.clone())),
        };

        assert_eq!(Some(child_node), root_node.get_next_node());
    }
}
